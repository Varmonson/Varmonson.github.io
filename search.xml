<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring 事务介绍]]></title>
    <url>%2F2019%2F11%2F07%2FSpring-%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Spring的事务管理机制Spring事务管理主要包括2个接口，Spring的事务主要是由他们共同完成的： PlatformTransactionManager：事务管理器—主要用于平台相关事务的管理 TransactionDefinition： 事务定义信息(隔离、传播、超时、只读)—通过配置如何进行事务管理。 PlatformTransactionManager事务管理器该接口提供三个方法： commit：提交事务 rollback：回滚事务 getTransaction：获取事务状态 Spring中又针对不同的数据源派生出了针对具体数据源的事务管理器,一下列表是Spring中针对不同数据源的事务管理器类 事务 说明 org.springframework.jdbc.datasource.DataSourceTransactionManager 使用Spring JDBC或iBatis 进行持久化数据时使用 org.springframework.orm.hibernate5.HibernateTransactionManager 使用Hibernate进行持久化数据时使用 org.springframework.orm.jpa.JpaTransactionManager 使用JPA进行持久化时使用 org.springframework.jdo.JdoTransactionManager 当持久化机制是Jdo时使用 org.springframework.transaction.jta.JtaTransactionManager 使用一个JTA实现来管理事务，在一个事务跨越多个资源时必须使用 TransactionDefinition事务定义信息该接口主要提供的方法： getIsolationLevel：隔离级别获取 getPropagationBehavior：传播行为获取 getTimeout：获取超时时间（事务的有效期） isReadOnly 是否只读(保存、更新、删除—对数据进行操作-变成可读写的，查询-设置这个属性为true，只能读不能写)，事务管理器能够根据这个返回值进行优化。 隔离级别(Isolation) 隔离级别 含义 DEFAULT 使用后端数据库默认的隔离级别(spring中的默认选择项) READ_UNCOMMITED 允许读取还未提交的改变了的数据。可能导致脏、幻、不可重复读 READ_COMMITTED 允许在并发事务已经提交后读取。可防止脏读，但幻读和 不可重复读仍可发生 REPEATABLE_READ 对相同字段的多次读取是一致的，除非数据被事务本身改变。可防止脏、不可重复读，但幻读仍可能发生。 SERIALIZABLE 完全服从ACID的隔离级别，确保不发生脏、幻、不可重复读。这在所有的隔离级别中是最慢的，它是典型的通过完全锁定在事务中涉及的数据表来完成的。 Mysql 默认隔离级别 REPEATABLE_READOracle 默认隔离级别 READ_COMMITTED 事务传播行为(propagation) 事务传播行为类型 说明 PROPAGATION_REQUIRED 支持当前事务，如果不存在 就新建一个 PROPAGATION_SUPPORTS 支持当前事务，如果不存在，就不使用事务 PROPAGATION_MANDATORY 支持当前事务，如果不存在，抛出异常 PROPAGATION_REQUIRES_NEW 如果有事务存在，挂起当前事务，创建一个新的事务 PROPAGATION_NOT_SUPPORTED 以非事务方式运行，如果有事务存在，挂起当前事务 PROPAGATION_NEVER 以非事务方式运行，如果有事务存在，抛出异常 PROPAGATION_NESTED 如果当前事务不存在，则新开启一个事务;如果存在事务，则运行在嵌套事务当中 其他问题1：PROPAGATION_REQUIRED、PROPAGATION_REQUIRED、PROPAGATION_NESTED三种级别的异同？对于methodA调用methodB情况(以下用A和B代替)：共同点：如果A不存在事务，三者都会创建一个事务；不同点：如果A存在事务，PROPAGATION_REQUIRED会沿用A的事务，如果A或B发生异常，A和B都会回滚；PROPAGATION_REQUIRED会将A的事务挂起，B新开启一个事务，此时若A发生异常，不会影响B的提交，若B发生异常，不会影响A的提交；PROPAGATION_NESTED在调用B之前，会将当前状态保存起来，若B发生异常，将恢复到保存的状态，继续执行A的后续操作，不会影响A的事务提交，若B未发生异常， B执行完毕事务并未提交，继续执行A的后续操作，若A后续操作出现异常，则B回滚。 问题2：对于同一个类中，如果methodA不存在事务，调用本类中的methodB存在事务，对于methodB而言，事务会不会生效？不管methodB设置哪种级别，事务都不会生效。原因：Spring采用动态代理(AOP)实现对bean的管理和切片，它为我们的每个class生成一个代理对象。只有在代理对象之间进行调用时，可以触发切面逻辑。 而在同一个class中，方法B调用方法A，调用的是原对象的方法，而不通过代理对象。所以Spring无法切到这次调用，也就无法通过注解保证事务性了。 也就是说，在同一个类中的方法调用，则不会被方法拦截器拦截到，因此事务不会起作用。 问题3：对于在挂起事务，开启新事务的情况，此时新事务的connection对象是同一个，还是新创建了一个连接对象？不是同一个。对于 REQUIRES_NEW ，methodA和methodB去获取了两次connection对象，两个connetion内存地址不同。 REQUIRED级别，仅获取了一次connetion对象。 问题4：对于REQUIRED、SUPPORTS、MANDATORY三种级别，如果在A中调用B，B抛出了异常，在A中捕获了异常，则Spring会抛出下面异常，为什么？ org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only Spring在通过代理类去执行invoke方法的时候会捕获当前方法的异常，若发生异常时，执行回滚操作，并设置当前事务属性为只能回滚。这三种级别中，A和B用的是同一个事务。在A调用B时，B发生异常，B进行事务回滚，同时将事务属性设置为rollbackOnly，此时A中捕获到B的异常并没有抛出此异常，所以A的代理类执行完毕并未捕获到异常，此时执行commit，但是在commit时发现B已经设置了当前事务属性为rollbackOnly，此时就会进行不正常(unexpected)回滚操作，并抛出上面描述异常。以下是运行过程：执行B方法时出现异常回滚的时候设置事务属性为rollbackOnly此时，继续执行A，A捕获异常未抛出，Spring代理类执行时没有捕获到异常，进行事务提交提交时发现事务属性已经被设置成rollbackOnly此时进行不正常的回滚并抛出以上描述异常 扩展：JTA分布式事务处理 : Java 事务编程接口（JTA：Java Transaction API）和 Java 事务服务 (JTS；Java Transaction Service) 为 J2EE 平台提供了分布式事务服务。分布式事务（Distributed Transaction）包括事务管理器（Transaction Manager）和一个或多个支持 XA 协议的资源管理器 ( Resource Manager )。我们可以将资源管理器看做任意类型的持久化数据存储；事务管理器承担着所有事务参与单元的协调与控制。JTA 事务有效的屏蔽了底层事务资源，使应用可以以透明的方式参入到事务处理中；但是与本地事务相比，XA 协议的系统开销大，在系统开发过程中应慎重考虑是否确实需要分布式事务。若确实需要分布式事务以协调多个事务资源，则应实现和配置所支持 XA 协议的事务资源，如 JMS、JDBC 数据库连接池等。使用 JTA 处理事务的示例如下（注意：connA 和 connB 是来自不同数据库的连接）。 参考资料：http://www.mamicode.com/info-detail-1248286.htmlhttps://www.bilibili.com/video/av68105906/?p=3&amp;t=1426问题2：https://blog.csdn.net/qq_30336433/article/details/83338835问题4：https://www.cnblogs.com/wangzhongqiu/p/7241058.htmlJTA：https://www.ibm.com/developerworks/cn/java/j-lo-jta/]]></content>
      <categories>
        <category>_ Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式]]></title>
    <url>%2F2019%2F03%2F04%2F%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近在学习设计模式，参考《大话设计模式》这本书，对23种设计模式做一些归档。下面先来看一下简单工厂模式。比如我现在要开发一个简单的计算器，直接创建一个计算器类，里面包含加减乘除四种运算法则，然后创建一个客户端类，根据用户的输入，去做运算。 1234567891011121314151617181920212223/*** 计算器类，计算四种运算法则*/public class Ccalculator &#123; public double add(double firstNum, double secNum)&#123; return firstNum + secNum; &#125; public double sub(double firstNum, double secNum)&#123; return firstNum - secNum; &#125; public double multiplication(double firstNum, double secNum)&#123; return firstNum * secNum; &#125; public double division(double firstNum, double secNum)&#123; if (secNum == 0)&#123; throw new RuntimeException("除数不能为0！"); &#125; return firstNum / secNum; &#125; &#125; 客户端代码： 12345678910111213141516171819202122/** * 客户端实现计算器*/public class CstApp &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println("请输入第一个数:"); String firstNum = scanner.nextLine(); System.out.println("请选择输入操作符+, -, *, ×, /:"); String operator = scanner.nextLine(); System.out.println("请输入第二个数："); String secNum = scanner.nextLine(); scanner.close(); Calculator calculate = CalculatorFacotry.createCalculate(operator); Double result = calculate.arithmetic(Double.valueOf(firstNum), Double.valueOf(secNum)); System.out.println("运算结果为:" + result); &#125;&#125; &emsp;&emsp;那此时如果我要做修改，再增加一个取模运算呢，就需要同时修改计算器类和客户端代码。首先在计算器类中添加一个取模的方法: 123456public double mod(double firstNum, double secNum)&#123; if (secNum == 0)&#123; throw new RuntimeException("除数不能为0！"); &#125; return firstNum % secNum;&#125; 然后在客户端再加一个取模的判断条件。 123case "%": result = ccalculator.mod(Double.valueOf(firstNum), Double.valueOf(secNum)); break; 我们可以看到，这么做虽然也能实现，但是耦合度太高了。一旦新增了需求，就要同时修改服务端和客户端代码，这样显然不好。对于计算器这个对象，他有一个运算的方法，因此我们可以定义一个Calculator接口，接口中声明一个arithmetic()方法。然后将每一个运算法则抽取出一个类实现Calculator接口，重写arithmetic()方法。然后再定义一个工厂类，利用多肽，来创建不同实例。UML图如下：下面看一下具体代码的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*** 计算器接口，接口中声明一个算术方法*/public interface Calculator &#123; Double arithmetic(double firstNum, double secNum);&#125;/*** 加法类*/public class AddImpl implements Calculator &#123; @Override public Double arithmetic(double firstNum, double secNum) &#123; return firstNum + secNum; &#125;&#125;/** * 减法类 */public class SubImpl implements Calculator &#123; @Override public Double arithmetic(double firstNum, double secNum) &#123; return firstNum - secNum; &#125;&#125;/** * 乘法类 */public class Multiplication implements Calculator &#123; @Override public Double arithmetic(double firstNum, double secNum) &#123; return firstNum * secNum; &#125;&#125;/** * 除法类 */public class DivisionImpl implements Calculator &#123; @Override public Double arithmetic(double firstNum, double secNum) &#123; if (secNum == 0)&#123; throw new RuntimeException("除数不能为0"); &#125; return firstNum / secNum; &#125;&#125; 定义一个工厂类，根据传入的运算符，生成对应的对象的实例： 1234567891011121314151617181920212223242526272829303132/** * 生产计算器的工厂类 */public class CalculatorFacotry &#123; /** * 根据运算符生产计算器的工厂 * @param operator 运算符 * @return */ public static Calculator createCalculate(String operator)&#123; Calculator calculator = null; switch (operator)&#123; case "+": calculator = new AddImpl(); break; case "-": calculator = new SubImpl(); break; case "*": case "×": calculator = new Multiplication(); break; case "/": calculator = new DivisionImpl(); break; default: throw new RuntimeException("您的操作有误！"); &#125; return calculator; &#125;&#125; 客户端实例化工厂对象，调用工厂创建计算器的方法，创建实例： 1234567891011121314151617181920212223/** * 客户端利用工厂类实现计算器 */public class CstApp &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println("请输入第一个数:"); String firstNum = scanner.nextLine(); System.out.println("请选择输入操作符+, -, *, ×, /:"); String operator = scanner.nextLine(); System.out.println("请叔叔第二个数："); String secNum = scanner.nextLine(); scanner.close(); // 传入运算符，调用工厂方法创建创建实例对象 Calculator calculate = CalculatorFacotry.createCalculate(operator); Double result = calculate.arithmetic(Double.valueOf(firstNum), Double.valueOf(secNum)); System.out.println("运算结果为:" + result); &#125;&#125; 此时我们要再增加一个取模运算的话，那么我只要创建一个取模的类实现Calculator接口 123456789101112/** * 取模类，实现计算器接口 */public class ModImpl implements Calculator &#123; @Override public Double arithmetic(double firstNum, double secNum) &#123; if (secNum == 0)&#123; throw new RuntimeException("除数不能为0"); &#125; return firstNum % secNum; &#125;&#125; 然后在工厂类中增加一个条件CalculatorFacotry: 123case "%": calculator = new ModImpl(); break; 而对于客户端代码来说，不需要做什么修改。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-单链表的实现]]></title>
    <url>%2F2019%2F01%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;链表是一种常见的数据结构，链表一般分为单向链表、双向链表和循环链表。本篇主要介绍单链表的原理和使用kjava语言实现单链表结构以及对单链表的一些基本操作。以下是维基百科对单链表的一种定义：单向链表(又名单链表、线性链表)是链表的一种，其特点是链表的链接是单向的，对链表的访问要通过从头部开始，依序往下读取。 从图片中可以清晰的看出，单链表每个节点有两部分组成，一部分用来存放数据元素，被称为数据域(图中data部分)，另一部分是下一节点的地址，被称为指针域(图中next部分)。尾结点的指针域为null链表中的各个节点在内存中的地址不一定是连续的，所以我们要找到链表中的某一个节点，必须要通过它的前驱结点，根据它的前驱结点的指针域来找到某该节点的内存地址。下面看一下具体实现：1234567891011121314151617181920212223242526272829/*** 自定义单链表 */public class SingleLinkedList&lt;E&gt; &#123; private MyNode&lt;E&gt; first; // 首节点 int size = 0; // 链表容量 int modCount = 0; // 修改次数 /** * 无参构造 */ public SingleLinkedList()&#123; &#125; /** * 数据节点 * @param &lt;E&gt; */ private static class MyNode&lt;E&gt;&#123; E data; // 数据域 MyNode&lt;E&gt; next; // 指针域 MyNode(E element, MyNode&lt;E&gt; next)&#123; this.data = element; this.next = next; &#125; &#125;&#125;首先自定义了一个类来表示单链表，其中有三个属性，分别记录首节点的地址、链表的容量和修改的次数。首节点地址用来以后操作链表。链表内部有一个内部类用来表示链表的节点，每个节点由一个数据域和指针域构成。1.查找在上面介绍过，单链表的指针域是下一个节点的地址。那么我们要获取某一指定位置的节点，我们要从首部节点开始遍历，拿到第n-1个节点，然后获取当前节点的数据域，以下是示例代码：1234567891011121314151617181920/** * 获取第n个节点的元素 * @param index * @return */E getNode(int index)&#123; return myNode(index).data;&#125;// 获取某一指定节点MyNode&lt;E&gt; myNode(int index) &#123; if (index &lt; 0 || index &gt; size) return null; // 获取第n-1个节点的下一个节点 MyNode&lt;E&gt; x = first; for (int i = 0; i &lt;= index - 1; i++)&#123; x = x.next; &#125; return x;&#125;2.增加对于链表首部和链表尾部添加元素比较简单。在首部添加元素，只需要将添加的节点的指针域指向首部的数据域即可，如下:1234567891011121314151617/** * 在第一个节点之前添加节点 * @param e */void addFirst(E e)&#123; linkFirst(e);&#125;void linkFirst(E e)&#123; MyNode f = first; // 获取链表首部 MyNode newNode = new MyNode(e, f); // 把新节点的指针域指向原首部节点 first = newNode; // 把指针指向新节点 size++; // 链表容量+1 modCount++; // 记录修改次数&#125;在尾部添加节点，拿到首部节点，遍历到链表最后一位，在其后插入新节点即可，如下：1234567891011121314151617181920/** * 在最后一个节点之后添加 * @param e */public void addLast(E e)&#123; linkLast(e);&#125;void linkLast(E e)&#123; MyNode pointer = first; MyNode newNode = new MyNode&lt;&gt;(e, null); for (int i = 0; i &lt; size - 1; i++) if (pointer.next != null) pointer = pointer.next; pointer.next = newNode; size++; // 增加容量 modCount++; // 累加修改次数&#125;首部和尾部都比较好实现，那如果要向某一指定位置插入节点该如何实现呢？我们首先要获取某一指定节点的前驱结点(这里要用到刚刚查询指定位置节点的方法)，然后把前驱结点指向要插入的节点，再把插入的新节点指向原链表的当前节点，代码如下:123456789101112131415161718/** * 向第n个节点后插入节点 * @param index * @param e */void add(int index, E e)&#123; // 获取第n个节点 MyNode&lt;E&gt; modNode = myNode(index); // 获取第n个节点中的前驱结点 MyNode&lt;E&gt; preNode = myNode(index-1); // 把插入的节点指向当前元素 MyNode newNode = new MyNode(e, modNode); // 把原链表的前驱结点指向新节点 preNode.next = newNode; size++; modCount++;&#125;3.删除删除指定节点，要先获取当前节点的前驱节点和后驱节点，然后把前驱节点指向后驱节点即可，代码示例：1234567891011121314151617181920212223242526/** * 删除指定的节点 * @param index * @return */E remove(int index)&#123; // 要移出的元素 E element = getNode(index); // 获取当前节点的前驱结点 MyNode&lt;E&gt; prevNode = myNode(index - 1); // 获取当前节点的后驱节点 MyNode&lt;E&gt; nextNode = myNode(index + 1); // 判断前一个节点是否为null if (prevNode == null)&#123; first = nextNode; // 移出第一个节点 &#125; else &#123; // 把当前节点的前驱指向当前节点的后驱 prevNode.next = nextNode; &#125; size--; modCount++; // 返回当前节点的元素 return element;&#125;以上就是单链表的基本操作,相对还比较简单。 本文是学习过程中自己的一点总结，如有不当之处，欢迎批评指正。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java</tag>
        <tag>单链表</tag>
      </tags>
  </entry>
</search>
