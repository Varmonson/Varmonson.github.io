<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[简单工厂模式]]></title>
    <url>%2F2019%2F03%2F04%2F%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近在学习设计模式，参考《大话设计模式》这本书，对23种设计模式做一些归档。下面先来看一下简单工厂模式。比如我现在要开发一个简单的计算器，直接创建一个计算器类，里面包含加减乘除四种运算法则，然后创建一个客户端类，根据用户的输入，去做运算。 1234567891011121314151617181920212223/*** 计算器类，计算四种运算法则*/public class Ccalculator &#123; public double add(double firstNum, double secNum)&#123; return firstNum + secNum; &#125; public double sub(double firstNum, double secNum)&#123; return firstNum - secNum; &#125; public double multiplication(double firstNum, double secNum)&#123; return firstNum * secNum; &#125; public double division(double firstNum, double secNum)&#123; if (secNum == 0)&#123; throw new RuntimeException("除数不能为0！"); &#125; return firstNum / secNum; &#125; &#125; 客户端代码： 12345678910111213141516171819202122/** * 客户端实现计算器*/public class CstApp &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println("请输入第一个数:"); String firstNum = scanner.nextLine(); System.out.println("请选择输入操作符+, -, *, ×, /:"); String operator = scanner.nextLine(); System.out.println("请输入第二个数："); String secNum = scanner.nextLine(); scanner.close(); Calculator calculate = CalculatorFacotry.createCalculate(operator); Double result = calculate.arithmetic(Double.valueOf(firstNum), Double.valueOf(secNum)); System.out.println("运算结果为:" + result); &#125;&#125; &emsp;&emsp;那此时如果我要做修改，再增加一个取模运算呢，就需要同时修改计算器类和客户端代码。首先在计算器类中添加一个取模的方法: 123456public double mod(double firstNum, double secNum)&#123; if (secNum == 0)&#123; throw new RuntimeException("除数不能为0！"); &#125; return firstNum % secNum;&#125; 然后在客户端再加一个取模的判断条件。 123case "%": result = ccalculator.mod(Double.valueOf(firstNum), Double.valueOf(secNum)); break; 我们可以看到，这么做虽然也能实现，但是耦合度太高了。一旦新增了需求，就要同时修改服务端和客户端代码，这样显然不好。对于计算器这个对象，他有一个运算的方法，因此我们可以定义一个Calculator接口，接口中声明一个arithmetic()方法。然后将每一个运算法则抽取出一个类实现Calculator接口，重写arithmetic()方法。然后再定义一个工厂类，利用多肽，来创建不同实例。UML图如下：下面看一下具体代码的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*** 计算器接口，接口中声明一个算术方法*/public interface Calculator &#123; Double arithmetic(double firstNum, double secNum);&#125;/*** 加法类*/public class AddImpl implements Calculator &#123; @Override public Double arithmetic(double firstNum, double secNum) &#123; return firstNum + secNum; &#125;&#125;/** * 减法类 */public class SubImpl implements Calculator &#123; @Override public Double arithmetic(double firstNum, double secNum) &#123; return firstNum - secNum; &#125;&#125;/** * 乘法类 */public class Multiplication implements Calculator &#123; @Override public Double arithmetic(double firstNum, double secNum) &#123; return firstNum * secNum; &#125;&#125;/** * 除法类 */public class DivisionImpl implements Calculator &#123; @Override public Double arithmetic(double firstNum, double secNum) &#123; if (secNum == 0)&#123; throw new RuntimeException("除数不能为0"); &#125; return firstNum / secNum; &#125;&#125; 定义一个工厂类，根据传入的运算符，生成对应的对象的实例： 1234567891011121314151617181920212223242526272829303132/** * 生产计算器的工厂类 */public class CalculatorFacotry &#123; /** * 根据运算符生产计算器的工厂 * @param operator 运算符 * @return */ public static Calculator createCalculate(String operator)&#123; Calculator calculator = null; switch (operator)&#123; case "+": calculator = new AddImpl(); break; case "-": calculator = new SubImpl(); break; case "*": case "×": calculator = new Multiplication(); break; case "/": calculator = new DivisionImpl(); break; default: throw new RuntimeException("您的操作有误！"); &#125; return calculator; &#125;&#125; 客户端实例化工厂对象，调用工厂创建计算器的方法，创建实例： 1234567891011121314151617181920212223/** * 客户端利用工厂类实现计算器 */public class CstApp &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println("请输入第一个数:"); String firstNum = scanner.nextLine(); System.out.println("请选择输入操作符+, -, *, ×, /:"); String operator = scanner.nextLine(); System.out.println("请叔叔第二个数："); String secNum = scanner.nextLine(); scanner.close(); // 传入运算符，调用工厂方法创建创建实例对象 Calculator calculate = CalculatorFacotry.createCalculate(operator); Double result = calculate.arithmetic(Double.valueOf(firstNum), Double.valueOf(secNum)); System.out.println("运算结果为:" + result); &#125;&#125; 此时我们要再增加一个取模运算的话，那么我只要创建一个取模的类实现Calculator接口 123456789101112/** * 取模类，实现计算器接口 */public class ModImpl implements Calculator &#123; @Override public Double arithmetic(double firstNum, double secNum) &#123; if (secNum == 0)&#123; throw new RuntimeException("除数不能为0"); &#125; return firstNum % secNum; &#125;&#125; 然后在工厂类中增加一个条件CalculatorFacotry: 123case "%": calculator = new ModImpl(); break; 而对于客户端代码来说，不需要做什么修改。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-单链表的实现]]></title>
    <url>%2F2019%2F01%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;链表是一种常见的数据结构，链表一般分为单向链表、双向链表和循环链表。本篇主要介绍单链表的原理和使用kjava语言实现单链表结构以及对单链表的一些基本操作。以下是维基百科对单链表的一种定义：单向链表(又名单链表、线性链表)是链表的一种，其特点是链表的链接是单向的，对链表的访问要通过从头部开始，依序往下读取。 从图片中可以清晰的看出，单链表每个节点有两部分组成，一部分用来存放数据元素，被称为数据域(图中data部分)，另一部分是下一节点的地址，被称为指针域(图中next部分)。尾结点的指针域为null链表中的各个节点在内存中的地址不一定是连续的，所以我们要找到链表中的某一个节点，必须要通过它的前驱结点，根据它的前驱结点的指针域来找到某该节点的内存地址。下面看一下具体实现：1234567891011121314151617181920212223242526272829/*** 自定义单链表 */public class SingleLinkedList&lt;E&gt; &#123; private MyNode&lt;E&gt; first; // 首节点 int size = 0; // 链表容量 int modCount = 0; // 修改次数 /** * 无参构造 */ public SingleLinkedList()&#123; &#125; /** * 数据节点 * @param &lt;E&gt; */ private static class MyNode&lt;E&gt;&#123; E data; // 数据域 MyNode&lt;E&gt; next; // 指针域 MyNode(E element, MyNode&lt;E&gt; next)&#123; this.data = element; this.next = next; &#125; &#125;&#125;首先自定义了一个类来表示单链表，其中有三个属性，分别记录首节点的地址、链表的容量和修改的次数。首节点地址用来以后操作链表。链表内部有一个内部类用来表示链表的节点，每个节点由一个数据域和指针域构成。1.查找在上面介绍过，单链表的指针域是下一个节点的地址。那么我们要获取某一指定位置的节点，我们要从首部节点开始遍历，拿到第n-1个节点，然后获取当前节点的数据域，以下是示例代码：1234567891011121314151617181920/** * 获取第n个节点的元素 * @param index * @return */E getNode(int index)&#123; return myNode(index).data;&#125;// 获取某一指定节点MyNode&lt;E&gt; myNode(int index) &#123; if (index &lt; 0 || index &gt; size) return null; // 获取第n-1个节点的下一个节点 MyNode&lt;E&gt; x = first; for (int i = 0; i &lt;= index - 1; i++)&#123; x = x.next; &#125; return x;&#125;2.增加对于链表首部和链表尾部添加元素比较简单。在首部添加元素，只需要将添加的节点的指针域指向首部的数据域即可，如下:1234567891011121314151617/** * 在第一个节点之前添加节点 * @param e */void addFirst(E e)&#123; linkFirst(e);&#125;void linkFirst(E e)&#123; MyNode f = first; // 获取链表首部 MyNode newNode = new MyNode(e, f); // 把新节点的指针域指向原首部节点 first = newNode; // 把指针指向新节点 size++; // 链表容量+1 modCount++; // 记录修改次数&#125;在尾部添加节点，拿到首部节点，遍历到链表最后一位，在其后插入新节点即可，如下：1234567891011121314151617181920/** * 在最后一个节点之后添加 * @param e */public void addLast(E e)&#123; linkLast(e);&#125;void linkLast(E e)&#123; MyNode pointer = first; MyNode newNode = new MyNode&lt;&gt;(e, null); for (int i = 0; i &lt; size - 1; i++) if (pointer.next != null) pointer = pointer.next; pointer.next = newNode; size++; // 增加容量 modCount++; // 累加修改次数&#125;首部和尾部都比较好实现，那如果要向某一指定位置插入节点该如何实现呢？我们首先要获取某一指定节点的前驱结点(这里要用到刚刚查询指定位置节点的方法)，然后把前驱结点指向要插入的节点，再把插入的新节点指向原链表的当前节点，代码如下:123456789101112131415161718/** * 向第n个节点后插入节点 * @param index * @param e */void add(int index, E e)&#123; // 获取第n个节点 MyNode&lt;E&gt; modNode = myNode(index); // 获取第n个节点中的前驱结点 MyNode&lt;E&gt; preNode = myNode(index-1); // 把插入的节点指向当前元素 MyNode newNode = new MyNode(e, modNode); // 把原链表的前驱结点指向新节点 preNode.next = newNode; size++; modCount++;&#125;3.删除删除指定节点，要先获取当前节点的前驱节点和后驱节点，然后把前驱节点指向后驱节点即可，代码示例：1234567891011121314151617181920212223242526/** * 删除指定的节点 * @param index * @return */E remove(int index)&#123; // 要移出的元素 E element = getNode(index); // 获取当前节点的前驱结点 MyNode&lt;E&gt; prevNode = myNode(index - 1); // 获取当前节点的后驱节点 MyNode&lt;E&gt; nextNode = myNode(index + 1); // 判断前一个节点是否为null if (prevNode == null)&#123; first = nextNode; // 移出第一个节点 &#125; else &#123; // 把当前节点的前驱指向当前节点的后驱 prevNode.next = nextNode; &#125; size--; modCount++; // 返回当前节点的元素 return element;&#125;以上就是单链表的基本操作,相对还比较简单。 本文是学习过程中自己的一点总结，如有不当之处，欢迎批评指正。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java</tag>
        <tag>单链表</tag>
      </tags>
  </entry>
</search>
