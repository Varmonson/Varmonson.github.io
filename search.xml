<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python基础学习(二)]]></title>
    <url>%2F2019%2F12%2F14%2FPython%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[1.数字类型 Python中的数字类型 1.1整数类型 1.2浮点数 1.3复数类型 1.4数值运算操作符 1.5数值运算函数 2.字符串类型 2.1字符串类型的表示 2.2字符串操作符 2.3字符串处理函数 2.4字符串处理方法 2.5字符串类型的格式化]]></content>
      <categories>
        <category>-- Python</category>
      </categories>
      <tags>
        <tag>-- Python -- 语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础学习(一)]]></title>
    <url>%2F2019%2F12%2F14%2FPython%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[《论语》中说:”学而时习之”。学习过的知识我们要时常去温习它。对于我们学习的知识，如果我们不去复习的话，过段时间我们可能就全忘记了。最近在中国大学(MOOC)上面学习《Python程序设计》，下面几篇笔记将对于Python语法基础的几个模块进行简单的介绍。​ 至于Python的安装，网上有很多教程，这里不再赘述，仅仅介绍Python的语法体系。对于大多数编程语言来说，基础语法结构都是一致的，只是语法上的实现略有差异，本次也将从以下几个方面对Python语法基础进行介绍。 本篇我们主要先介绍Python的基础语法。 1.基础语法在学习Python的基础知识点之前，我们首先了解一下Python基本的语法格式：变量的声明、注释、行结束符以及语句的输入输出。 1.1变量的声明如果你习惯了其他语言的声明变量，比如Java，刚开始接触Python，你可能会很不适应。在Java语言中，你要声明一个变量，必须要先给出变量的类型。1int i = 5; // 声明一个整形变量 而在Python中，你不需要给出变量的具体类型，Python会根据给出的值的类型，将你定义的变量识别为相应的类型。12# 声明一个整形i = 5; 1.2注释的使用Ⅰ. Python中的单行注释使用的是 ‘#’，比如在上面定义变量的时候我们给出的注释。 Ⅱ.多行注释使用 三个单引号’’’ ‘’’的形式。1234''' 这是python语言的 多行注释''' 其实Python中不存在多行注释的方式。’’’ ‘’’这种表示的只是创建了一个字符串（后面介绍字符串时会提到），但是并没有地方使用这个字符串，所以我们就可以把它当作注释。当一行注释不能满足我们的需求，需要写多行注释的时候，我们可以使用这种方式。 1.3行结束符对于Java语言，除了条件语句之外，一行语句的结束必须要用使用英文分号（’;’），不然编译时就会报错。而对于Python语言来说语句结尾的’;’却不是必须的，可以写也可以不写。但是如果一行包含了多句代码的话则必须写。如下面的输入输出的例子。 1.4语句输入输出Python的输入输出语句比较简单，使用input()函数和print()函数即可。12345678# 输出一个字符串。 一行只有一条语句，可以不加';'&gt;&gt;&gt; print("Hello world!")Hello world!# 获取从键盘输入的字符，并打印输出。 一行有多条语句,语句中间必须写';'&gt;&gt;&gt; s = input("请输入一个字符:"); print(s)请输入一个字符:Hello, world!Hello, world!&gt;&gt;&gt; 本篇先介绍了一些Python的基本的语法格式，让我们对Python有一个简单的认识，下面我们将介绍Python中的基本数据类型。]]></content>
      <categories>
        <category>-- Python</category>
      </categories>
      <tags>
        <tag>-- Python -- 语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker基础入门]]></title>
    <url>%2F2019%2F11%2F14%2FDocker%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Docker是什么Docker作为一个软件集装箱化平台，可以让开发者构建应用程序时，将它与其依赖环境一起打包到一个容器中，然后很容易地发布和应用到任意平台中。 Docker的应用场景 Web 应用的自动化打包和发布。 自动化测试和持续集成、发布。 在服务型环境中部署和调整数据库或其他的后台应用。 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。 docker组件:镜像(Images)：相当于root文件系统，用来创建docker容器的模板。容器(Container)：独立运行的一个或一组应用，是镜像运行时的实体。仓库(Repository):代码控制中心，保存镜像。 Centos下面安装dokcer卸载旧版本 sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine 安装配置仓库 sudo yum install -y yum-utils \device-mapper-persistent-data \lvm2 sudo yum-config-manager \ –add-repo \ https://download.docker.com/linux/centos/docker-ce.repo 安装最新版本的docker engine-community和contanierd sudo yum install docker-ce \ docker-ce-cli \ containerd.io 制作Dokcer镜像从Docker仓库拉取镜像 docker image pull xxx 通过镜像启动一个Docker容器 docker container run -itd -p 80:8080 –name=xxx xxx:xxx bash参数说明： -i：交互式操作 -t：终端 -d：后台启动 -p：指定容器的80端口映射到宿主机的8080端口 –name=xx：指定创建容器的名字 xxx:xxx：镜像名:版本号 bash：以bash命令创建，可以执行shell脚本 通过DockerFile构建服务DockerFile FROM docker.io/tomcat # 基于tomcat镜像制作镜像COPY xxx.war /usr/local/tomcat/webapps #将war包复制到镜像当前目录下 通过DockerFile构建镜像 docker build -t xxx:tag .参数说明: -t：指定镜像的文件名 xxx：镜像名 .：表示当前路径， 创建容器 docker container run -itd -p 80:8080 –name=xxx xxx:xxx bash Docker指令 查看所有镜像 docker images / docker image ls 删除镜像(需将容器删除) docker rmi [id/repository…] 启动docker容器 docker start [id/name] 停止运行的docker容器 docker stop [id/name] 停止所有容器 docker stop $(docker ps -a -q) 删除容器 docker rm [id/name] 查询运行的docker容器 dokcer ps 查询所有的docker容器 docker ps -a 进入容器 docker attach [id/name] / docker exec -it [id] /bin/bash注:attach退出之后会停止容器，建议使用exec 参考:https://www.runoob.com/docker/docker-tutorial.htmlhttps://docs.docker.com/get-started/ 关于DockerFile指令详解参见：https://www.cnblogs.com/kirito-c/p/11145892.html]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>服务部署</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 事务介绍]]></title>
    <url>%2F2019%2F11%2F07%2FSpring-%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Spring的事务管理机制Spring事务管理主要包括2个接口，Spring的事务主要是由他们共同完成的： PlatformTransactionManager：事务管理器—主要用于平台相关事务的管理 TransactionDefinition： 事务定义信息(隔离、传播、超时、只读)—通过配置如何进行事务管理。 PlatformTransactionManager事务管理器该接口提供三个方法： commit：提交事务 rollback：回滚事务 getTransaction：获取事务状态 Spring中又针对不同的数据源派生出了针对具体数据源的事务管理器,一下列表是Spring中针对不同数据源的事务管理器类 事务 说明 org.springframework.jdbc.datasource.DataSourceTransactionManager 使用Spring JDBC或iBatis 进行持久化数据时使用 org.springframework.orm.hibernate5.HibernateTransactionManager 使用Hibernate进行持久化数据时使用 org.springframework.orm.jpa.JpaTransactionManager 使用JPA进行持久化时使用 org.springframework.jdo.JdoTransactionManager 当持久化机制是Jdo时使用 org.springframework.transaction.jta.JtaTransactionManager 使用一个JTA实现来管理事务，在一个事务跨越多个资源时必须使用 TransactionDefinition事务定义信息该接口主要提供的方法： getIsolationLevel：隔离级别获取 getPropagationBehavior：传播行为获取 getTimeout：获取超时时间（事务的有效期） isReadOnly 是否只读(保存、更新、删除—对数据进行操作-变成可读写的，查询-设置这个属性为true，只能读不能写)，事务管理器能够根据这个返回值进行优化。 隔离级别(Isolation) 隔离级别 含义 DEFAULT 使用后端数据库默认的隔离级别(spring中的默认选择项) READ_UNCOMMITED 允许读取还未提交的改变了的数据。可能导致脏、幻、不可重复读 READ_COMMITTED 允许在并发事务已经提交后读取。可防止脏读，但幻读和 不可重复读仍可发生 REPEATABLE_READ 对相同字段的多次读取是一致的，除非数据被事务本身改变。可防止脏、不可重复读，但幻读仍可能发生。 SERIALIZABLE 完全服从ACID的隔离级别，确保不发生脏、幻、不可重复读。这在所有的隔离级别中是最慢的，它是典型的通过完全锁定在事务中涉及的数据表来完成的。 Mysql 默认隔离级别 REPEATABLE_READOracle 默认隔离级别 READ_COMMITTED 事务传播行为(propagation) 事务传播行为类型 说明 PROPAGATION_REQUIRED 支持当前事务，如果不存在 就新建一个 PROPAGATION_SUPPORTS 支持当前事务，如果不存在，就不使用事务 PROPAGATION_MANDATORY 支持当前事务，如果不存在，抛出异常 PROPAGATION_REQUIRES_NEW 如果有事务存在，挂起当前事务，创建一个新的事务 PROPAGATION_NOT_SUPPORTED 以非事务方式运行，如果有事务存在，挂起当前事务 PROPAGATION_NEVER 以非事务方式运行，如果有事务存在，抛出异常 PROPAGATION_NESTED 如果当前事务不存在，则新开启一个事务;如果存在事务，则运行在嵌套事务当中 其他问题1：PROPAGATION_REQUIRED、PROPAGATION_REQUIRED、PROPAGATION_NESTED三种级别的异同？对于methodA调用methodB情况(以下用A和B代替)：共同点：如果A不存在事务，三者都会创建一个事务；不同点：如果A存在事务，PROPAGATION_REQUIRED会沿用A的事务，如果A或B发生异常，A和B都会回滚；PROPAGATION_REQUIRED会将A的事务挂起，B新开启一个事务，此时若A发生异常，不会影响B的提交，若B发生异常，不会影响A的提交；PROPAGATION_NESTED在调用B之前，会将当前状态保存起来，若B发生异常，将恢复到保存的状态，继续执行A的后续操作，不会影响A的事务提交，若B未发生异常， B执行完毕事务并未提交，继续执行A的后续操作，若A后续操作出现异常，则B回滚。 问题2：对于同一个类中，如果methodA不存在事务，调用本类中的methodB存在事务，对于methodB而言，事务会不会生效？不管methodB设置哪种级别，事务都不会生效。原因：Spring采用动态代理(AOP)实现对bean的管理和切片，它为我们的每个class生成一个代理对象。只有在代理对象之间进行调用时，可以触发切面逻辑。 而在同一个class中，方法B调用方法A，调用的是原对象的方法，而不通过代理对象。所以Spring无法切到这次调用，也就无法通过注解保证事务性了。 也就是说，在同一个类中的方法调用，则不会被方法拦截器拦截到，因此事务不会起作用。 问题3：对于在挂起事务，开启新事务的情况，此时新事务的connection对象是同一个，还是新创建了一个连接对象？不是同一个。对于 REQUIRES_NEW ，methodA和methodB去获取了两次connection对象，两个connetion内存地址不同。 REQUIRED级别，仅获取了一次connetion对象。 问题4：对于REQUIRED、SUPPORTS、MANDATORY三种级别，如果在A中调用B，B抛出了异常，在A中捕获了异常，则Spring会抛出下面异常，为什么？ org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only Spring在通过代理类去执行invoke方法的时候会捕获当前方法的异常，若发生异常时，执行回滚操作，并设置当前事务属性为只能回滚。这三种级别中，A和B用的是同一个事务。在A调用B时，B发生异常，B进行事务回滚，同时将事务属性设置为rollbackOnly，此时A中捕获到B的异常并没有抛出此异常，所以A的代理类执行完毕并未捕获到异常，此时执行commit，但是在commit时发现B已经设置了当前事务属性为rollbackOnly，此时就会进行不正常(unexpected)回滚操作，并抛出上面描述异常。以下是运行过程：执行B方法时出现异常回滚的时候设置事务属性为rollbackOnly此时，继续执行A，A捕获异常未抛出，Spring代理类执行时没有捕获到异常，进行事务提交提交时发现事务属性已经被设置成rollbackOnly此时进行不正常的回滚并抛出以上描述异常 扩展：JTA分布式事务处理 : Java 事务编程接口（JTA：Java Transaction API）和 Java 事务服务 (JTS；Java Transaction Service) 为 J2EE 平台提供了分布式事务服务。分布式事务（Distributed Transaction）包括事务管理器（Transaction Manager）和一个或多个支持 XA 协议的资源管理器 ( Resource Manager )。我们可以将资源管理器看做任意类型的持久化数据存储；事务管理器承担着所有事务参与单元的协调与控制。JTA 事务有效的屏蔽了底层事务资源，使应用可以以透明的方式参入到事务处理中；但是与本地事务相比，XA 协议的系统开销大，在系统开发过程中应慎重考虑是否确实需要分布式事务。若确实需要分布式事务以协调多个事务资源，则应实现和配置所支持 XA 协议的事务资源，如 JMS、JDBC 数据库连接池等。使用 JTA 处理事务的示例如下（注意：connA 和 connB 是来自不同数据库的连接）。 参考资料：http://www.mamicode.com/info-detail-1248286.htmlhttps://www.bilibili.com/video/av68105906/?p=3&amp;t=1426问题2：https://blog.csdn.net/qq_30336433/article/details/83338835问题4：https://www.cnblogs.com/wangzhongqiu/p/7241058.htmlJTA：https://www.ibm.com/developerworks/cn/java/j-lo-jta/]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式]]></title>
    <url>%2F2019%2F03%2F04%2F%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最近在学习设计模式，参考《大话设计模式》这本书，对23种设计模式做一些归档。下面先来看一下简单工厂模式。比如我现在要开发一个简单的计算器，直接创建一个计算器类，里面包含加减乘除四种运算法则，然后创建一个客户端类，根据用户的输入，去做运算。 1234567891011121314151617181920212223/*** 计算器类，计算四种运算法则*/public class Ccalculator &#123; public double add(double firstNum, double secNum)&#123; return firstNum + secNum; &#125; public double sub(double firstNum, double secNum)&#123; return firstNum - secNum; &#125; public double multiplication(double firstNum, double secNum)&#123; return firstNum * secNum; &#125; public double division(double firstNum, double secNum)&#123; if (secNum == 0)&#123; throw new RuntimeException("除数不能为0！"); &#125; return firstNum / secNum; &#125; &#125; 客户端代码： 12345678910111213141516171819202122/** * 客户端实现计算器*/public class CstApp &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println("请输入第一个数:"); String firstNum = scanner.nextLine(); System.out.println("请选择输入操作符+, -, *, ×, /:"); String operator = scanner.nextLine(); System.out.println("请输入第二个数："); String secNum = scanner.nextLine(); scanner.close(); Calculator calculate = CalculatorFacotry.createCalculate(operator); Double result = calculate.arithmetic(Double.valueOf(firstNum), Double.valueOf(secNum)); System.out.println("运算结果为:" + result); &#125;&#125; &emsp;&emsp;那此时如果我要做修改，再增加一个取模运算呢，就需要同时修改计算器类和客户端代码。首先在计算器类中添加一个取模的方法: 123456public double mod(double firstNum, double secNum)&#123; if (secNum == 0)&#123; throw new RuntimeException("除数不能为0！"); &#125; return firstNum % secNum;&#125; 然后在客户端再加一个取模的判断条件。 123case "%": result = ccalculator.mod(Double.valueOf(firstNum), Double.valueOf(secNum)); break; 我们可以看到，这么做虽然也能实现，但是耦合度太高了。一旦新增了需求，就要同时修改服务端和客户端代码，这样显然不好。对于计算器这个对象，他有一个运算的方法，因此我们可以定义一个Calculator接口，接口中声明一个arithmetic()方法。然后将每一个运算法则抽取出一个类实现Calculator接口，重写arithmetic()方法。然后再定义一个工厂类，利用多肽，来创建不同实例。UML图如下：下面看一下具体代码的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*** 计算器接口，接口中声明一个算术方法*/public interface Calculator &#123; Double arithmetic(double firstNum, double secNum);&#125;/*** 加法类*/public class AddImpl implements Calculator &#123; @Override public Double arithmetic(double firstNum, double secNum) &#123; return firstNum + secNum; &#125;&#125;/** * 减法类 */public class SubImpl implements Calculator &#123; @Override public Double arithmetic(double firstNum, double secNum) &#123; return firstNum - secNum; &#125;&#125;/** * 乘法类 */public class Multiplication implements Calculator &#123; @Override public Double arithmetic(double firstNum, double secNum) &#123; return firstNum * secNum; &#125;&#125;/** * 除法类 */public class DivisionImpl implements Calculator &#123; @Override public Double arithmetic(double firstNum, double secNum) &#123; if (secNum == 0)&#123; throw new RuntimeException("除数不能为0"); &#125; return firstNum / secNum; &#125;&#125; 定义一个工厂类，根据传入的运算符，生成对应的对象的实例： 1234567891011121314151617181920212223242526272829303132/** * 生产计算器的工厂类 */public class CalculatorFacotry &#123; /** * 根据运算符生产计算器的工厂 * @param operator 运算符 * @return */ public static Calculator createCalculate(String operator)&#123; Calculator calculator = null; switch (operator)&#123; case "+": calculator = new AddImpl(); break; case "-": calculator = new SubImpl(); break; case "*": case "×": calculator = new Multiplication(); break; case "/": calculator = new DivisionImpl(); break; default: throw new RuntimeException("您的操作有误！"); &#125; return calculator; &#125;&#125; 客户端实例化工厂对象，调用工厂创建计算器的方法，创建实例： 1234567891011121314151617181920212223/** * 客户端利用工厂类实现计算器 */public class CstApp &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println("请输入第一个数:"); String firstNum = scanner.nextLine(); System.out.println("请选择输入操作符+, -, *, ×, /:"); String operator = scanner.nextLine(); System.out.println("请叔叔第二个数："); String secNum = scanner.nextLine(); scanner.close(); // 传入运算符，调用工厂方法创建创建实例对象 Calculator calculate = CalculatorFacotry.createCalculate(operator); Double result = calculate.arithmetic(Double.valueOf(firstNum), Double.valueOf(secNum)); System.out.println("运算结果为:" + result); &#125;&#125; 此时我们要再增加一个取模运算的话，那么我只要创建一个取模的类实现Calculator接口 123456789101112/** * 取模类，实现计算器接口 */public class ModImpl implements Calculator &#123; @Override public Double arithmetic(double firstNum, double secNum) &#123; if (secNum == 0)&#123; throw new RuntimeException("除数不能为0"); &#125; return firstNum % secNum; &#125;&#125; 然后在工厂类中增加一个条件CalculatorFacotry: 123case "%": calculator = new ModImpl(); break; 而对于客户端代码来说，不需要做什么修改。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-单链表的实现]]></title>
    <url>%2F2019%2F01%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;链表是一种常见的数据结构，链表一般分为单向链表、双向链表和循环链表。本篇主要介绍单链表的原理和使用kjava语言实现单链表结构以及对单链表的一些基本操作。以下是维基百科对单链表的一种定义：单向链表(又名单链表、线性链表)是链表的一种，其特点是链表的链接是单向的，对链表的访问要通过从头部开始，依序往下读取。 从图片中可以清晰的看出，单链表每个节点有两部分组成，一部分用来存放数据元素，被称为数据域(图中data部分)，另一部分是下一节点的地址，被称为指针域(图中next部分)。尾结点的指针域为null链表中的各个节点在内存中的地址不一定是连续的，所以我们要找到链表中的某一个节点，必须要通过它的前驱结点，根据它的前驱结点的指针域来找到某该节点的内存地址。下面看一下具体实现：1234567891011121314151617181920212223242526272829/*** 自定义单链表 */public class SingleLinkedList&lt;E&gt; &#123; private MyNode&lt;E&gt; first; // 首节点 int size = 0; // 链表容量 int modCount = 0; // 修改次数 /** * 无参构造 */ public SingleLinkedList()&#123; &#125; /** * 数据节点 * @param &lt;E&gt; */ private static class MyNode&lt;E&gt;&#123; E data; // 数据域 MyNode&lt;E&gt; next; // 指针域 MyNode(E element, MyNode&lt;E&gt; next)&#123; this.data = element; this.next = next; &#125; &#125;&#125;首先自定义了一个类来表示单链表，其中有三个属性，分别记录首节点的地址、链表的容量和修改的次数。首节点地址用来以后操作链表。链表内部有一个内部类用来表示链表的节点，每个节点由一个数据域和指针域构成。1.查找在上面介绍过，单链表的指针域是下一个节点的地址。那么我们要获取某一指定位置的节点，我们要从首部节点开始遍历，拿到第n-1个节点，然后获取当前节点的数据域，以下是示例代码：1234567891011121314151617181920/** * 获取第n个节点的元素 * @param index * @return */E getNode(int index)&#123; return myNode(index).data;&#125;// 获取某一指定节点MyNode&lt;E&gt; myNode(int index) &#123; if (index &lt; 0 || index &gt; size) return null; // 获取第n-1个节点的下一个节点 MyNode&lt;E&gt; x = first; for (int i = 0; i &lt;= index - 1; i++)&#123; x = x.next; &#125; return x;&#125;2.增加对于链表首部和链表尾部添加元素比较简单。在首部添加元素，只需要将添加的节点的指针域指向首部的数据域即可，如下:1234567891011121314151617/** * 在第一个节点之前添加节点 * @param e */void addFirst(E e)&#123; linkFirst(e);&#125;void linkFirst(E e)&#123; MyNode f = first; // 获取链表首部 MyNode newNode = new MyNode(e, f); // 把新节点的指针域指向原首部节点 first = newNode; // 把指针指向新节点 size++; // 链表容量+1 modCount++; // 记录修改次数&#125;在尾部添加节点，拿到首部节点，遍历到链表最后一位，在其后插入新节点即可，如下：1234567891011121314151617181920/** * 在最后一个节点之后添加 * @param e */public void addLast(E e)&#123; linkLast(e);&#125;void linkLast(E e)&#123; MyNode pointer = first; MyNode newNode = new MyNode&lt;&gt;(e, null); for (int i = 0; i &lt; size - 1; i++) if (pointer.next != null) pointer = pointer.next; pointer.next = newNode; size++; // 增加容量 modCount++; // 累加修改次数&#125;首部和尾部都比较好实现，那如果要向某一指定位置插入节点该如何实现呢？我们首先要获取某一指定节点的前驱结点(这里要用到刚刚查询指定位置节点的方法)，然后把前驱结点指向要插入的节点，再把插入的新节点指向原链表的当前节点，代码如下:123456789101112131415161718/** * 向第n个节点后插入节点 * @param index * @param e */void add(int index, E e)&#123; // 获取第n个节点 MyNode&lt;E&gt; modNode = myNode(index); // 获取第n个节点中的前驱结点 MyNode&lt;E&gt; preNode = myNode(index-1); // 把插入的节点指向当前元素 MyNode newNode = new MyNode(e, modNode); // 把原链表的前驱结点指向新节点 preNode.next = newNode; size++; modCount++;&#125;3.删除删除指定节点，要先获取当前节点的前驱节点和后驱节点，然后把前驱节点指向后驱节点即可，代码示例：1234567891011121314151617181920212223242526/** * 删除指定的节点 * @param index * @return */E remove(int index)&#123; // 要移出的元素 E element = getNode(index); // 获取当前节点的前驱结点 MyNode&lt;E&gt; prevNode = myNode(index - 1); // 获取当前节点的后驱节点 MyNode&lt;E&gt; nextNode = myNode(index + 1); // 判断前一个节点是否为null if (prevNode == null)&#123; first = nextNode; // 移出第一个节点 &#125; else &#123; // 把当前节点的前驱指向当前节点的后驱 prevNode.next = nextNode; &#125; size--; modCount++; // 返回当前节点的元素 return element;&#125;以上就是单链表的基本操作,相对还比较简单。 本文是学习过程中自己的一点总结，如有不当之处，欢迎批评指正。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>单链表</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>
